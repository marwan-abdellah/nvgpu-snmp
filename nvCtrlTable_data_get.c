/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12088 $ of $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "nvCtrlTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement nvCtrlTable get routines.
 * TODO:240:M: Implement nvCtrlTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table nvCtrlTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * NV-CTRL-MIB::nvCtrlTable is subid 2 of nvCtrl.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.2021.13.42.2, length: 10
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement nvCtrlTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param nvCtrlGPU_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
nvCtrlTable_indexes_set_tbl_idx(nvCtrlTable_mib_index *tbl_idx, long nvCtrlGPU_val)
{
    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlTable_indexes_set_tbl_idx","called\n"));

    /* nvCtrlGPU(1)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->nvCtrlGPU = nvCtrlGPU_val;
    

    return MFD_SUCCESS;
} /* nvCtrlTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
nvCtrlTable_indexes_set(nvCtrlTable_rowreq_ctx *rowreq_ctx, long nvCtrlGPU_val)
{
    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlTable_indexes_set","called\n"));

    if(MFD_SUCCESS != nvCtrlTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , nvCtrlGPU_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != nvCtrlTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* nvCtrlTable_indexes_set */


/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlProductName
 * nvCtrlProductName is subid 2 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.2
 * Description:
GPU product name
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the nvCtrlProductName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlProductName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param nvCtrlProductName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by nvCtrlProductName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*nvCtrlProductName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update nvCtrlProductName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
nvCtrlProductName_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, char **nvCtrlProductName_val_ptr_ptr, size_t *nvCtrlProductName_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != nvCtrlProductName_val_ptr_ptr) && (NULL != *nvCtrlProductName_val_ptr_ptr));
   netsnmp_assert( NULL != nvCtrlProductName_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlProductName_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlProductName data.
 * copy (* nvCtrlProductName_val_ptr_ptr ) data and (* nvCtrlProductName_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for nvCtrlProductName data
     */
    if ((NULL == (* nvCtrlProductName_val_ptr_ptr )) ||
        ((* nvCtrlProductName_val_ptr_len_ptr ) <
         (rowreq_ctx->data.nvCtrlProductName_len* sizeof(rowreq_ctx->data.nvCtrlProductName[0])))) {
        /*
         * allocate space for nvCtrlProductName data
         */
        (* nvCtrlProductName_val_ptr_ptr ) = malloc(rowreq_ctx->data.nvCtrlProductName_len* sizeof(rowreq_ctx->data.nvCtrlProductName[0]));
        if(NULL == (* nvCtrlProductName_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* nvCtrlProductName_val_ptr_len_ptr ) = rowreq_ctx->data.nvCtrlProductName_len* sizeof(rowreq_ctx->data.nvCtrlProductName[0]);
    memcpy( (* nvCtrlProductName_val_ptr_ptr ), rowreq_ctx->data.nvCtrlProductName, rowreq_ctx->data.nvCtrlProductName_len* sizeof(rowreq_ctx->data.nvCtrlProductName[0]) );

    return MFD_SUCCESS;
} /* nvCtrlProductName_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlVBiosVersion
 * nvCtrlVBiosVersion is subid 3 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.3
 * Description:
video bios version on the GPU
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the nvCtrlVBiosVersion data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlVBiosVersion_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param nvCtrlVBiosVersion_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by nvCtrlVBiosVersion.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*nvCtrlVBiosVersion_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update nvCtrlVBiosVersion_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
nvCtrlVBiosVersion_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, char **nvCtrlVBiosVersion_val_ptr_ptr, size_t *nvCtrlVBiosVersion_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != nvCtrlVBiosVersion_val_ptr_ptr) && (NULL != *nvCtrlVBiosVersion_val_ptr_ptr));
   netsnmp_assert( NULL != nvCtrlVBiosVersion_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlVBiosVersion_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlVBiosVersion data.
 * copy (* nvCtrlVBiosVersion_val_ptr_ptr ) data and (* nvCtrlVBiosVersion_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for nvCtrlVBiosVersion data
     */
    if ((NULL == (* nvCtrlVBiosVersion_val_ptr_ptr )) ||
        ((* nvCtrlVBiosVersion_val_ptr_len_ptr ) <
         (rowreq_ctx->data.nvCtrlVBiosVersion_len* sizeof(rowreq_ctx->data.nvCtrlVBiosVersion[0])))) {
        /*
         * allocate space for nvCtrlVBiosVersion data
         */
        (* nvCtrlVBiosVersion_val_ptr_ptr ) = malloc(rowreq_ctx->data.nvCtrlVBiosVersion_len* sizeof(rowreq_ctx->data.nvCtrlVBiosVersion[0]));
        if(NULL == (* nvCtrlVBiosVersion_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* nvCtrlVBiosVersion_val_ptr_len_ptr ) = rowreq_ctx->data.nvCtrlVBiosVersion_len* sizeof(rowreq_ctx->data.nvCtrlVBiosVersion[0]);
    memcpy( (* nvCtrlVBiosVersion_val_ptr_ptr ), rowreq_ctx->data.nvCtrlVBiosVersion, rowreq_ctx->data.nvCtrlVBiosVersion_len* sizeof(rowreq_ctx->data.nvCtrlVBiosVersion[0]) );

    return MFD_SUCCESS;
} /* nvCtrlVBiosVersion_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlNvidiaDriverVersion
 * nvCtrlNvidiaDriverVersion is subid 4 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.4
 * Description:
NVIDIA driver version number for the NVIDIA X driver in use
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the nvCtrlNvidiaDriverVersion data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlNvidiaDriverVersion_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param nvCtrlNvidiaDriverVersion_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by nvCtrlNvidiaDriverVersion.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*nvCtrlNvidiaDriverVersion_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update nvCtrlNvidiaDriverVersion_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
nvCtrlNvidiaDriverVersion_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, char **nvCtrlNvidiaDriverVersion_val_ptr_ptr, size_t *nvCtrlNvidiaDriverVersion_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != nvCtrlNvidiaDriverVersion_val_ptr_ptr) && (NULL != *nvCtrlNvidiaDriverVersion_val_ptr_ptr));
   netsnmp_assert( NULL != nvCtrlNvidiaDriverVersion_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlNvidiaDriverVersion_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlNvidiaDriverVersion data.
 * copy (* nvCtrlNvidiaDriverVersion_val_ptr_ptr ) data and (* nvCtrlNvidiaDriverVersion_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for nvCtrlNvidiaDriverVersion data
     */
    if ((NULL == (* nvCtrlNvidiaDriverVersion_val_ptr_ptr )) ||
        ((* nvCtrlNvidiaDriverVersion_val_ptr_len_ptr ) <
         (rowreq_ctx->data.nvCtrlNvidiaDriverVersion_len* sizeof(rowreq_ctx->data.nvCtrlNvidiaDriverVersion[0])))) {
        /*
         * allocate space for nvCtrlNvidiaDriverVersion data
         */
        (* nvCtrlNvidiaDriverVersion_val_ptr_ptr ) = malloc(rowreq_ctx->data.nvCtrlNvidiaDriverVersion_len* sizeof(rowreq_ctx->data.nvCtrlNvidiaDriverVersion[0]));
        if(NULL == (* nvCtrlNvidiaDriverVersion_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* nvCtrlNvidiaDriverVersion_val_ptr_len_ptr ) = rowreq_ctx->data.nvCtrlNvidiaDriverVersion_len* sizeof(rowreq_ctx->data.nvCtrlNvidiaDriverVersion[0]);
    memcpy( (* nvCtrlNvidiaDriverVersion_val_ptr_ptr ), rowreq_ctx->data.nvCtrlNvidiaDriverVersion, rowreq_ctx->data.nvCtrlNvidiaDriverVersion_len* sizeof(rowreq_ctx->data.nvCtrlNvidiaDriverVersion[0]) );

    return MFD_SUCCESS;
} /* nvCtrlNvidiaDriverVersion_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlVersion
 * nvCtrlVersion is subid 5 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.5
 * Description:
NV-CONTROL extension version
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the nvCtrlVersion data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlVersion_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param nvCtrlVersion_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by nvCtrlVersion.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*nvCtrlVersion_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update nvCtrlVersion_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
nvCtrlVersion_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, char **nvCtrlVersion_val_ptr_ptr, size_t *nvCtrlVersion_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != nvCtrlVersion_val_ptr_ptr) && (NULL != *nvCtrlVersion_val_ptr_ptr));
   netsnmp_assert( NULL != nvCtrlVersion_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlVersion_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlVersion data.
 * copy (* nvCtrlVersion_val_ptr_ptr ) data and (* nvCtrlVersion_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for nvCtrlVersion data
     */
    if ((NULL == (* nvCtrlVersion_val_ptr_ptr )) ||
        ((* nvCtrlVersion_val_ptr_len_ptr ) <
         (rowreq_ctx->data.nvCtrlVersion_len* sizeof(rowreq_ctx->data.nvCtrlVersion[0])))) {
        /*
         * allocate space for nvCtrlVersion data
         */
        (* nvCtrlVersion_val_ptr_ptr ) = malloc(rowreq_ctx->data.nvCtrlVersion_len* sizeof(rowreq_ctx->data.nvCtrlVersion[0]));
        if(NULL == (* nvCtrlVersion_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* nvCtrlVersion_val_ptr_len_ptr ) = rowreq_ctx->data.nvCtrlVersion_len* sizeof(rowreq_ctx->data.nvCtrlVersion[0]);
    memcpy( (* nvCtrlVersion_val_ptr_ptr ), rowreq_ctx->data.nvCtrlVersion, rowreq_ctx->data.nvCtrlVersion_len* sizeof(rowreq_ctx->data.nvCtrlVersion[0]) );

    return MFD_SUCCESS;
} /* nvCtrlVersion_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlBusType
 * nvCtrlBusType is subid 6 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.6
 * Description:
Bus type through which the GPU is connected to the computer
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlBusType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlBusType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlBusType_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlBusType_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlBusType_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlBusType_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlBusType data.
 * copy (* nvCtrlBusType_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlBusType_val_ptr ) = rowreq_ctx->data.nvCtrlBusType;

    return MFD_SUCCESS;
} /* nvCtrlBusType_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlBusRate
 * nvCtrlBusRate is subid 7 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.7
 * Description:
AGP transfer rate or PCI Express width
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlBusRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlBusRate_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlBusRate_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlBusRate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlBusRate_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlBusRate_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlBusRate data.
 * copy (* nvCtrlBusRate_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlBusRate_val_ptr ) = rowreq_ctx->data.nvCtrlBusRate;

    return MFD_SUCCESS;
} /* nvCtrlBusRate_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlVideoRam
 * nvCtrlVideoRam is subid 8 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.8
 * Description:
total amount of memory available to the GPU
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlVideoRam data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlVideoRam_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlVideoRam_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlVideoRam_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlVideoRam_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlVideoRam_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlVideoRam data.
 * copy (* nvCtrlVideoRam_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlVideoRam_val_ptr ) = rowreq_ctx->data.nvCtrlVideoRam;

    return MFD_SUCCESS;
} /* nvCtrlVideoRam_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlIrq
 * nvCtrlIrq is subid 9 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.9
 * Description:
interrupt request line used by the GPU
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlIrq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlIrq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlIrq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlIrq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlIrq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlIrq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlIrq data.
 * copy (* nvCtrlIrq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlIrq_val_ptr ) = rowreq_ctx->data.nvCtrlIrq;

    return MFD_SUCCESS;
} /* nvCtrlIrq_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUCoreTemp
 * nvCtrlGPUCoreTemp is subid 10 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.10
 * Description:
current core temperature of the GPU
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUCoreTemp data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUCoreTemp_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUCoreTemp_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUCoreTemp_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUCoreTemp_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUCoreTemp_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUCoreTemp data.
 * copy (* nvCtrlGPUCoreTemp_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUCoreTemp_val_ptr ) = rowreq_ctx->data.nvCtrlGPUCoreTemp;

    return MFD_SUCCESS;
} /* nvCtrlGPUCoreTemp_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUCoreThreshold
 * nvCtrlGPUCoreThreshold is subid 11 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.11
 * Description:
current GPU core slowdown threshold temperature
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUCoreThreshold data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUCoreThreshold_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUCoreThreshold_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUCoreThreshold_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUCoreThreshold_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUCoreThreshold_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUCoreThreshold data.
 * copy (* nvCtrlGPUCoreThreshold_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUCoreThreshold_val_ptr ) = rowreq_ctx->data.nvCtrlGPUCoreThreshold;

    return MFD_SUCCESS;
} /* nvCtrlGPUCoreThreshold_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUDefaultCoreThreshold
 * nvCtrlGPUDefaultCoreThreshold is subid 12 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.12
 * Description:
default core slowdown threshold temperature
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUDefaultCoreThreshold data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUDefaultCoreThreshold_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUDefaultCoreThreshold_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUDefaultCoreThreshold_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUDefaultCoreThreshold_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUDefaultCoreThreshold_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUDefaultCoreThreshold data.
 * copy (* nvCtrlGPUDefaultCoreThreshold_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUDefaultCoreThreshold_val_ptr ) = rowreq_ctx->data.nvCtrlGPUDefaultCoreThreshold;

    return MFD_SUCCESS;
} /* nvCtrlGPUDefaultCoreThreshold_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUMaxCoreThreshold
 * nvCtrlGPUMaxCoreThreshold is subid 13 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.13
 * Description:
maximum core slowdown threshold temperature
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUMaxCoreThreshold data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUMaxCoreThreshold_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUMaxCoreThreshold_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUMaxCoreThreshold_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUMaxCoreThreshold_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUMaxCoreThreshold_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUMaxCoreThreshold data.
 * copy (* nvCtrlGPUMaxCoreThreshold_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUMaxCoreThreshold_val_ptr ) = rowreq_ctx->data.nvCtrlGPUMaxCoreThreshold;

    return MFD_SUCCESS;
} /* nvCtrlGPUMaxCoreThreshold_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUAmbientTemp
 * nvCtrlGPUAmbientTemp is subid 14 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.14
 * Description:
current temperature in the immediate neighbourhood of the GPU
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUAmbientTemp data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUAmbientTemp_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUAmbientTemp_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUAmbientTemp_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUAmbientTemp_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUAmbientTemp_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUAmbientTemp data.
 * copy (* nvCtrlGPUAmbientTemp_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUAmbientTemp_val_ptr ) = rowreq_ctx->data.nvCtrlGPUAmbientTemp;

    return MFD_SUCCESS;
} /* nvCtrlGPUAmbientTemp_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUOverclockingState
 * nvCtrlGPUOverclockingState is subid 15 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.15
 * Description:
query the availability of additional overclocking attributes
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUOverclockingState data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUOverclockingState_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUOverclockingState_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUOverclockingState_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUOverclockingState_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUOverclockingState_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUOverclockingState data.
 * copy (* nvCtrlGPUOverclockingState_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUOverclockingState_val_ptr ) = rowreq_ctx->data.nvCtrlGPUOverclockingState;

    return MFD_SUCCESS;
} /* nvCtrlGPUOverclockingState_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPU2DGPUClockFreq
 * nvCtrlGPU2DGPUClockFreq is subid 16 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.16
 * Description:
2D GPU clock frequency in MHz
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPU2DGPUClockFreq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPU2DGPUClockFreq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPU2DGPUClockFreq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPU2DGPUClockFreq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPU2DGPUClockFreq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPU2DGPUClockFreq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPU2DGPUClockFreq data.
 * copy (* nvCtrlGPU2DGPUClockFreq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPU2DGPUClockFreq_val_ptr ) = rowreq_ctx->data.nvCtrlGPU2DGPUClockFreq;

    return MFD_SUCCESS;
} /* nvCtrlGPU2DGPUClockFreq_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPU2DMemClockFreq
 * nvCtrlGPU2DMemClockFreq is subid 17 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.17
 * Description:
2D memory clock frequency in MHz
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPU2DMemClockFreq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPU2DMemClockFreq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPU2DMemClockFreq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPU2DMemClockFreq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPU2DMemClockFreq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPU2DMemClockFreq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPU2DMemClockFreq data.
 * copy (* nvCtrlGPU2DMemClockFreq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPU2DMemClockFreq_val_ptr ) = rowreq_ctx->data.nvCtrlGPU2DMemClockFreq;

    return MFD_SUCCESS;
} /* nvCtrlGPU2DMemClockFreq_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPU3DGPUClockFreq
 * nvCtrlGPU3DGPUClockFreq is subid 18 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.18
 * Description:
3D GPU clock frequency in MHz
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPU3DGPUClockFreq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPU3DGPUClockFreq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPU3DGPUClockFreq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPU3DGPUClockFreq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPU3DGPUClockFreq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPU3DGPUClockFreq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPU3DGPUClockFreq data.
 * copy (* nvCtrlGPU3DGPUClockFreq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPU3DGPUClockFreq_val_ptr ) = rowreq_ctx->data.nvCtrlGPU3DGPUClockFreq;

    return MFD_SUCCESS;
} /* nvCtrlGPU3DGPUClockFreq_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPU3DMemClockFreq
 * nvCtrlGPU3DMemClockFreq is subid 19 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.19
 * Description:
3D memory clock frequency in MHz
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPU3DMemClockFreq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPU3DMemClockFreq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPU3DMemClockFreq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPU3DMemClockFreq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPU3DMemClockFreq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPU3DMemClockFreq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPU3DMemClockFreq data.
 * copy (* nvCtrlGPU3DMemClockFreq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPU3DMemClockFreq_val_ptr ) = rowreq_ctx->data.nvCtrlGPU3DMemClockFreq;

    return MFD_SUCCESS;
} /* nvCtrlGPU3DMemClockFreq_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUDefault2DGPUClockFreq
 * nvCtrlGPUDefault2DGPUClockFreq is subid 20 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.20
 * Description:
default 2D GPU clock frequency in MHz
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUDefault2DGPUClockFreq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUDefault2DGPUClockFreq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUDefault2DGPUClockFreq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUDefault2DGPUClockFreq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUDefault2DGPUClockFreq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUDefault2DGPUClockFreq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUDefault2DGPUClockFreq data.
 * copy (* nvCtrlGPUDefault2DGPUClockFreq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUDefault2DGPUClockFreq_val_ptr ) = rowreq_ctx->data.nvCtrlGPUDefault2DGPUClockFreq;

    return MFD_SUCCESS;
} /* nvCtrlGPUDefault2DGPUClockFreq_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUDefault2DMemClockFreq
 * nvCtrlGPUDefault2DMemClockFreq is subid 21 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.21
 * Description:
default 2D memory clock frequency in MHz
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUDefault2DMemClockFreq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUDefault2DMemClockFreq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUDefault2DMemClockFreq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUDefault2DMemClockFreq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUDefault2DMemClockFreq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUDefault2DMemClockFreq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUDefault2DMemClockFreq data.
 * copy (* nvCtrlGPUDefault2DMemClockFreq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUDefault2DMemClockFreq_val_ptr ) = rowreq_ctx->data.nvCtrlGPUDefault2DMemClockFreq;

    return MFD_SUCCESS;
} /* nvCtrlGPUDefault2DMemClockFreq_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUDefault3DGPUClockFreq
 * nvCtrlGPUDefault3DGPUClockFreq is subid 22 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.22
 * Description:
default 3D GPU clock frequency in MHz
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUDefault3DGPUClockFreq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUDefault3DGPUClockFreq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUDefault3DGPUClockFreq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUDefault3DGPUClockFreq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUDefault3DGPUClockFreq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUDefault3DGPUClockFreq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUDefault3DGPUClockFreq data.
 * copy (* nvCtrlGPUDefault3DGPUClockFreq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUDefault3DGPUClockFreq_val_ptr ) = rowreq_ctx->data.nvCtrlGPUDefault3DGPUClockFreq;

    return MFD_SUCCESS;
} /* nvCtrlGPUDefault3DGPUClockFreq_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUDefault3DMemClockFreq
 * nvCtrlGPUDefault3DMemClockFreq is subid 23 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.23
 * Description:
default 3D memory clock frequency in MHz
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUDefault3DMemClockFreq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUDefault3DMemClockFreq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUDefault3DMemClockFreq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUDefault3DMemClockFreq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUDefault3DMemClockFreq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUDefault3DMemClockFreq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUDefault3DMemClockFreq data.
 * copy (* nvCtrlGPUDefault3DMemClockFreq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUDefault3DMemClockFreq_val_ptr ) = rowreq_ctx->data.nvCtrlGPUDefault3DMemClockFreq;

    return MFD_SUCCESS;
} /* nvCtrlGPUDefault3DMemClockFreq_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUCurrentGPUClockFreq
 * nvCtrlGPUCurrentGPUClockFreq is subid 24 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.24
 * Description:
current GPU clock frequency in MHz
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUCurrentGPUClockFreq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUCurrentGPUClockFreq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUCurrentGPUClockFreq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUCurrentGPUClockFreq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUCurrentGPUClockFreq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUCurrentGPUClockFreq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUCurrentGPUClockFreq data.
 * copy (* nvCtrlGPUCurrentGPUClockFreq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUCurrentGPUClockFreq_val_ptr ) = rowreq_ctx->data.nvCtrlGPUCurrentGPUClockFreq;

    return MFD_SUCCESS;
} /* nvCtrlGPUCurrentGPUClockFreq_get */

/*---------------------------------------------------------------------
 * NV-CTRL-MIB::nvCtrlEntry.nvCtrlGPUCurrentMemClockFreq
 * nvCtrlGPUCurrentMemClockFreq is subid 25 of nvCtrlEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2021.13.42.2.1.25
 * Description:
current memory clock frequency in MHz
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the nvCtrlGPUCurrentMemClockFreq data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param nvCtrlGPUCurrentMemClockFreq_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
nvCtrlGPUCurrentMemClockFreq_get( nvCtrlTable_rowreq_ctx *rowreq_ctx, long * nvCtrlGPUCurrentMemClockFreq_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != nvCtrlGPUCurrentMemClockFreq_val_ptr );


    DEBUGMSGTL(("verbose:nvCtrlTable:nvCtrlGPUCurrentMemClockFreq_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the nvCtrlGPUCurrentMemClockFreq data.
 * copy (* nvCtrlGPUCurrentMemClockFreq_val_ptr ) from rowreq_ctx->data
 */
    (* nvCtrlGPUCurrentMemClockFreq_val_ptr ) = rowreq_ctx->data.nvCtrlGPUCurrentMemClockFreq;

    return MFD_SUCCESS;
} /* nvCtrlGPUCurrentMemClockFreq_get */



/** @} */
